{"ast":null,"code":"/* CONFIGS */\nimport appConfig from '../appConfig.json';\n/* CONTROLLERS */\n\nimport { getCurrentPlayerInstance } from './PlayerManager';\nimport { savePlayerToLocalStorage } from './StorageManager';\n/* MODELS */\n\nimport BusinessesCatalog from '../models/BusinessesCatalog';\n/**\n * This function returns all the available current player businesses\n * @returns {*}\n */\n\nconst getBoughtBusinessesList = () => getCurrentPlayerInstance().businesses;\n/**\n * This function returns all the available businesses to buy\n * @returns {[]}\n */\n\n\nconst getAvailableBusinessList = () => {\n  // create a support object to avoid n*n loop\n  const tempObjectForCheckIfBusinessAlreadyBought = {};\n  getCurrentPlayerInstance().businesses.forEach(elem => tempObjectForCheckIfBusinessAlreadyBought[elem.ID] = 1); // check if player has already bought one of the available business\n\n  return BusinessesCatalog.filter(elem => tempObjectForCheckIfBusinessAlreadyBought[elem.ID] !== 1);\n};\n/**\n * This function allows to buy a business\n * @param business\n * @returns {boolean}\n */\n\n\nconst buyBusinesses = business => {\n  // TODO: improve negative response\n  // check if there are enough money\n  if (getCurrentPlayerInstance().money < business.INITIAL_COST) return false; // buy adding it to player business array\n\n  getCurrentPlayerInstance().businesses.push(business); // decrease player money\n\n  getCurrentPlayerInstance().money -= business.INITIAL_COST; // save player to LS\n\n  savePlayerToLocalStorage();\n  return true;\n};\n/**\n * This function allows to update a business level\n * @param businessId\n * @returns {boolean}\n */\n\n\nconst updateBusinessLevel = businessId => {\n  // TODO: improve negative response\n  let currentBusinessToUpdate = getCurrentPlayerInstance().businesses.filter(elem => elem.ID === businessId)[0];\n  if (currentBusinessToUpdate === undefined) return false; // check if you reached max level\n\n  if (currentBusinessToUpdate.CURRENT_LEVEL >= appConfig.BUSINESSES_CONFIG.MAX_LEVEL_AMOUNT) return false; // set the price for next upgrade\n\n  const priceForTheUpdate = (currentBusinessToUpdate.CURRENT_LEVEL + 1) * currentBusinessToUpdate.INITIAL_COST; // check if you have enough money\n\n  if (getCurrentPlayerInstance().money < priceForTheUpdate) return false; // update the selected business\n\n  getCurrentPlayerInstance().businesses.map(elem => {\n    if (elem.ID === businessId) {\n      elem.CURRENT_LEVEL += 1;\n    }\n  }); // decrease current money\n\n  getCurrentPlayerInstance().money -= priceForTheUpdate; // flush to localStorage\n\n  savePlayerToLocalStorage();\n  return true;\n};\n/**\n * This functions allows to buy a manager for a specific business\n * @param businessId\n * @returns {string}\n */\n\n\nconst updateBusinessManager = businessId => {\n  // TODO: improve negative response\n  // retrieve the current business\n  let currentBusinessToUpdate = getCurrentPlayerInstance().businesses.filter(elem => elem.ID === businessId)[0];\n  if (currentBusinessToUpdate === undefined) return false; // check if you reached max level\n\n  if (currentBusinessToUpdate.HAS_MANAGER) return false; // check if you have enough money\n\n  if (getCurrentPlayerInstance().money < currentBusinessToUpdate.MANAGER_COST) return false; // update the current business with manager = true\n\n  getCurrentPlayerInstance().businesses.map(elem => {\n    if (elem.ID === businessId) elem.HAS_MANAGER = true;\n  }); // update current money\n\n  getCurrentPlayerInstance().money -= currentBusinessToUpdate.MANAGER_COST; // flush to localStorage\n\n  savePlayerToLocalStorage();\n  return true;\n};\n/**\n * This functions update the last progress for each businesses whether or not has manager\n * @param businessId\n * @param currentSeconds\n * @returns {boolean}\n */\n\n\nconst updateOnGoingTransaction = (businessId, currentSeconds) => {\n  // TODO: improve negative response\n  // retrieve current business and update last progress seconds\n  getCurrentPlayerInstance().businesses.map(elem => {\n    if (elem.ID === businessId) {\n      elem.LAST_ONGOING_SECONDS_TRANSACTION = parseInt(currentSeconds);\n    }\n  }); // flush to localStorage\n\n  savePlayerToLocalStorage();\n  return true;\n};\n\nexport { getBoughtBusinessesList, getAvailableBusinessList, buyBusinesses, updateBusinessLevel, updateBusinessManager, updateOnGoingTransaction };","map":{"version":3,"sources":["/Users/pierfrancescodorsogna/Documents/PROJECTS/adventure-cap_italy_st/controllers/BusinessManager.js"],"names":["appConfig","getCurrentPlayerInstance","savePlayerToLocalStorage","BusinessesCatalog","getBoughtBusinessesList","businesses","getAvailableBusinessList","tempObjectForCheckIfBusinessAlreadyBought","forEach","elem","ID","filter","buyBusinesses","business","money","INITIAL_COST","push","updateBusinessLevel","businessId","currentBusinessToUpdate","undefined","CURRENT_LEVEL","BUSINESSES_CONFIG","MAX_LEVEL_AMOUNT","priceForTheUpdate","map","updateBusinessManager","HAS_MANAGER","MANAGER_COST","updateOnGoingTransaction","currentSeconds","LAST_ONGOING_SECONDS_TRANSACTION","parseInt"],"mappings":"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","sourcesContent":["/* CONFIGS */\nimport appConfig from '../appConfig.json';\n/* CONTROLLERS */\nimport { getCurrentPlayerInstance } from './PlayerManager';\nimport { savePlayerToLocalStorage } from './StorageManager';\n/* MODELS */\nimport BusinessesCatalog from '../models/BusinessesCatalog';\n\n/**\n * This function returns all the available current player businesses\n * @returns {*}\n */\nconst getBoughtBusinessesList = () => getCurrentPlayerInstance().businesses;\n\n/**\n * This function returns all the available businesses to buy\n * @returns {[]}\n */\nconst getAvailableBusinessList = () => {\n\n  // create a support object to avoid n*n loop\n  const tempObjectForCheckIfBusinessAlreadyBought = {};\n  getCurrentPlayerInstance()\n    .businesses\n    .forEach(elem => tempObjectForCheckIfBusinessAlreadyBought[elem.ID] = 1);\n\n  // check if player has already bought one of the available business\n  return BusinessesCatalog\n    .filter(elem => tempObjectForCheckIfBusinessAlreadyBought[elem.ID] !== 1);\n}\n\n/**\n * This function allows to buy a business\n * @param business\n * @returns {boolean}\n */\nconst buyBusinesses = (business) => {\n\n  // TODO: improve negative response\n\n  // check if there are enough money\n  if (getCurrentPlayerInstance().money < business.INITIAL_COST) return false;\n\n  // buy adding it to player business array\n  getCurrentPlayerInstance().businesses.push(business);\n\n  // decrease player money\n  getCurrentPlayerInstance().money -= business.INITIAL_COST;\n\n  // save player to LS\n  savePlayerToLocalStorage();\n\n  return true;\n\n}\n\n/**\n * This function allows to update a business level\n * @param businessId\n * @returns {boolean}\n */\nconst updateBusinessLevel = (businessId) => {\n\n  // TODO: improve negative response\n  let currentBusinessToUpdate = getCurrentPlayerInstance().businesses.filter(elem => elem.ID === businessId)[0];\n  if (currentBusinessToUpdate === undefined) return false;\n\n  // check if you reached max level\n  if (currentBusinessToUpdate.CURRENT_LEVEL >= appConfig.BUSINESSES_CONFIG.MAX_LEVEL_AMOUNT) return false\n\n  // set the price for next upgrade\n  const priceForTheUpdate = (currentBusinessToUpdate.CURRENT_LEVEL + 1) * currentBusinessToUpdate.INITIAL_COST;\n\n  // check if you have enough money\n  if (getCurrentPlayerInstance().money < priceForTheUpdate) return false\n\n  // update the selected business\n  getCurrentPlayerInstance().businesses.map(elem => {\n    if (elem.ID === businessId) {\n      elem.CURRENT_LEVEL += 1;\n    }\n  });\n\n  // decrease current money\n  getCurrentPlayerInstance().money -= priceForTheUpdate;\n\n  // flush to localStorage\n  savePlayerToLocalStorage();\n\n  return true;\n}\n\n/**\n * This functions allows to buy a manager for a specific business\n * @param businessId\n * @returns {string}\n */\nconst updateBusinessManager = (businessId) => {\n  // TODO: improve negative response\n\n  // retrieve the current business\n  let currentBusinessToUpdate = getCurrentPlayerInstance().businesses.filter(elem => elem.ID === businessId)[0];\n  if (currentBusinessToUpdate === undefined) return false;\n\n  // check if you reached max level\n  if (currentBusinessToUpdate.HAS_MANAGER) return false;\n\n  // check if you have enough money\n  if (getCurrentPlayerInstance().money < currentBusinessToUpdate.MANAGER_COST) return false;\n\n  // update the current business with manager = true\n  getCurrentPlayerInstance().businesses.map(elem => {\n    if (elem.ID === businessId) elem.HAS_MANAGER = true;\n  });\n\n  // update current money\n  getCurrentPlayerInstance().money -= currentBusinessToUpdate.MANAGER_COST;\n\n  // flush to localStorage\n  savePlayerToLocalStorage();\n\n  return true;\n}\n\n/**\n * This functions update the last progress for each businesses whether or not has manager\n * @param businessId\n * @param currentSeconds\n * @returns {boolean}\n */\nconst updateOnGoingTransaction = (businessId, currentSeconds) => {\n  // TODO: improve negative response\n\n  // retrieve current business and update last progress seconds\n  getCurrentPlayerInstance().businesses.map(elem => {\n    if (elem.ID === businessId) {\n      elem.LAST_ONGOING_SECONDS_TRANSACTION = parseInt(currentSeconds);\n    }\n  });\n\n  // flush to localStorage\n  savePlayerToLocalStorage();\n\n  return true;\n}\n\nexport {\n  getBoughtBusinessesList,\n  getAvailableBusinessList,\n  buyBusinesses,\n  updateBusinessLevel,\n  updateBusinessManager,\n  updateOnGoingTransaction\n}\n"]},"metadata":{},"sourceType":"module"}